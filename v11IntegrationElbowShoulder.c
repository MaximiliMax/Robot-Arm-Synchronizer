#pragma config(Sensor, S1,     HTAC,           sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* hitechnic-accelerometer.h provides an API for the HiTechnic Acceleration Sensor.  This program
* demonstrates how to use that API.
*
* Changelog:
* - 0.1: Initial release
* - 0.2: Make use of new API calls
* - 0.3: Better comments
* - 0.4: Fixed display line (thanks Dave)
* - 0.5: Removed single axis functions, they're no longer in the driver\n
*        Removed common.h from includes
*
* Credits:
* - Big thanks to HiTechnic for providing me with the hardware necessary to write and test this.
*
* License: You may use this code as you wish, provided you give credit where it's due.
*
* THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 4.10 AND HIGHER

* Xander Soldaat (xander_at_botbench.com)
* 20 February 2011
* version 0.5
*/


#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment 4.X\Sample Programs\EV3\3rd Party Driver Library\include\hitechnic-accelerometer.h"
// Create struct to hold sensor data
// Create struct to hold sensor data
  tHTAC accelerometer;

task TFour()
{
	while(true)
	{
	if(nMotorEncoder(motorA)>nMotorEncoder(motorD)){
			motor[motorD] = 20;
			while ((nMotorEncoder(motorD))<((nMotorEncoder(motorA))*2))
			{
				displayString(5,"%f",nMotorEncoder(motorA));
			}
			motor[motorD] = 0;

		}else
		{
			motor[motorD] = -20;
			while (nMotorEncoder(motorA)<=nMotorEncoder(motorD)/2)
			{}
			motor[motorD] = 0;
		}
}
	}

task TThree()
{
	//Loop continously
	while(true)
	{
		eraseDisplay();
		float angle = getGyroDegrees(S2);
		displayTextLine(7,"%f",angle);
		displayString(8,"%f",nMotorEncoder(motorB));

			wait1Msec(100);
		if(((angle*-1))>(nMotorEncoder(motorB)))
		{
			motor[motorB] = 5;
			displayString(9,"right");
		}
		else if ((angle*-1)<(nMotorEncoder(motorB)))
		{
			motor[motorB] = -5;
			displayString(9,"left");
			}else{
			motor[motorB] = 0;
		}
	}
	wait1Msec(100);
}


task TTwo()
{

	//Loop continously
	while(true)
	{
	//	eraseDisplay();
		// Read all of the axes at once
		if (!readSensor(&accelerometer)) {
			displayTextLine(4, "ERROR!!");
	wait1Msec(2000);
			stopAllTasks();
	}


		//displayTextLine(0,"HTAC Test 1");
		//displayTextLine(2, "   X    Y    Z");

		//  displayTextLine(3, "%4d %4d %4d", accelerometer.x, accelerometer.y, accelerometer.z);
		// Alternatively, you can read them like this:
		//displayTextLine(4, "%4d %4d %4d", accelerometer.axes[0], accelerometer.axes[1], accelerometer.axes[2]);
		//displayTextLine(4,"%f",((accelerometer.x)/2));
		//displayTextLine(6,"%f",nMotorEncoder(motorC));

		if(((accelerometer.x)/2*4)>(nMotorEncoder(motorC)))
		{
			motor[motorC] = 20;
			displayString(8,"%f",nMotorEncoder(motorC));
			displayString(9,"lower");
		}
		else if(((accelerometer.x)/2*4)<(nMotorEncoder(motorC)))
		{
			motor[motorC] = -20;
		}
		else{
			motor[motorC] = 0;
		}
		wait1Msec(100);
	}

}


/*task TOne()
{
	//Loop continously
	while(true)
	{
		//If button is active
		while(SensorValue[S3]==1)
		{
			//Degbugging
			displayString(6,"touch");

			//Close gripper
			motor[motorD] = -5;
			//Debug
			displayString(8,"%f",nMotorEncoder(motorD));
			//Wait some time so no overloading occurs
			wait1Msec(50);
		}
		//If gripper sensor is not active, then return to opened state
		//While gripper is not fully open
		while(nMotorEncoder(motorD)<0){
			//Debug
			displayString(6," No touch");
			//open gripper
			motor[motorD] = 5;
			//Debug
			displayString(8,"%f",nMotorEncoder(motorD));
			wait1Msec(50);
		}
		//Otherwise if the gripper is at the fully opened angle, stop it from opening any further
		motor[motorD] = 0;
	}
}
*/
task main () {
	// Initialise and ctHTAC accelerometer;onfigure struct and port
	initSensor(&accelerometer, S1);
	SensorType[S2] = sensorEV3_Gyro;
	wait1Msec(50);
	SensorMode[S2] = modeEV3Gyro_Calibration;
	wait1Msec(50);
	SensorMode[S2] = modeEV3Gyro_RateAndAngle;
	wait1Msec(50);
	//displayCenteredTextLine(0, "HiTechnic");
	//displayCenteredBigTextLine(1, "Accel");
	//displayCenteredTextLine(3, "Test 1");
	//displayCenteredTextLine(5, "Connect sensor");
	//displayCenteredTextLine(6, "to S1");
//	sleep(2000);
	nMotorEncoder(motorC) = 0;
	nMotorEncoder(motorB) = 0;
	nMotorEncoder(motorA) = 0;
	nMotorEncoder(motorD) = 0;
	startTask(TTwo);
		wait1Msec(2000);
	startTask(TThree);
	startTask(TFour);
	//startTask(TOne);
	if(getMotorBrakeMode(motorD) != motorCoast)
	{
		setMotorBrakeMode(motorA, motorCoast);
	}
	displayString(3,"Coast");


			while(true)
		{
			wait1Msec(200);                                 // Allow for a short wait, freeing up the CPU for other tasks.
			displayCenteredBigTextLine(0, "TASK M");     // Display that Main is running.
		}
		return;
}
